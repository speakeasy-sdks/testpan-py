"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from .clusterpoddefinitionsource import ClusterPodDefinitionSource
from .controllerdataresponse import ControllerDataResponse
from .controllerstatus import ControllerStatus
from .helmcommandsinstallation import HelmCommandsInstallation
from .installationsource import InstallationSource
from .internalregistryparameters import InternalRegistryParameters
from .istioinstallationparameters import IstioInstallationParameters
from .kubernetesannotation import KubernetesAnnotation
from .proxyconfiguration import ProxyConfiguration
from .scanconfiguration import ScanConfiguration
from .sidecarsresource import SidecarsResource
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from pan import utils
from typing import List, Optional

class OrchestrationType(str, Enum):
    GKE = 'GKE'
    OPENSHIFT = 'OPENSHIFT'
    RANCHER = 'RANCHER'
    AKS = 'AKS'
    EKS = 'EKS'
    KUBERNETES = 'KUBERNETES'
    IKS = 'IKS'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class KubernetesCluster:
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    account_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('accountName'), 'exclude': lambda f: f is None }})
    agent_fail_close: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('agentFailClose'), 'exclude': lambda f: f is None }})
    r"""indicates fail close behavior on Secure Application agent failure"""
    api_intelligence_dast: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('apiIntelligenceDAST'), 'exclude': lambda f: f is None }})
    r"""indicates whether apiIntelligenceDAST is enabled"""
    auto_label_enabled: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('autoLabelEnabled'), 'exclude': lambda f: f is None }})
    r"""indicates whether auto label is enabled"""
    auto_upgrade_controller_version: Optional[bool] = dataclasses.field(default=True, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('autoUpgradeControllerVersion'), 'exclude': lambda f: f is None }})
    r"""indicates whether upgrade the controller automatically"""
    automated_policy_requires_deployer: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('automatedPolicyRequiresDeployer'), 'exclude': lambda f: f is None }})
    r"""indicates whether deployer is required for the automated policy"""
    ci_image_signature_validation: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ciImageSignatureValidation'), 'exclude': lambda f: f is None }})
    r"""Enable pod template images signature validation"""
    ci_image_validation: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ciImageValidation'), 'exclude': lambda f: f is None }})
    r"""Enable pod template images validation"""
    cluster_pod_definition_source: Optional[ClusterPodDefinitionSource] = dataclasses.field(default=ClusterPodDefinitionSource.KUBERNETES, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('clusterPodDefinitionSource'), 'exclude': lambda f: f is None }})
    r"""The source type of the pod definitions of the cluster"""
    controller_data_response: Optional[ControllerDataResponse] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('controllerDataResponse'), 'exclude': lambda f: f is None }})
    controller_status: Optional[ControllerStatus] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('controllerStatus'), 'exclude': lambda f: f is None }})
    r"""The current controller state."""
    enable_connections_control: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enableConnectionsControl'), 'exclude': lambda f: f is None }})
    r"""indicates whether Secure Application allows connections actions and detections"""
    helm_commands_installation: Optional[HelmCommandsInstallation] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('helmCommandsInstallation'), 'exclude': lambda f: f is None }})
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Id of the cluster."""
    install_envoy_tracing_support: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('installEnvoyTracingSupport'), 'exclude': lambda f: f is None }})
    r"""indicates whether envoy/istio will be used as a trace source"""
    install_tracing_support: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('installTracingSupport'), 'exclude': lambda f: f is None }})
    r"""indicates whether to install tracing support, enable for apiSecurity accounts"""
    installation_source: Optional[InstallationSource] = dataclasses.field(default=InstallationSource.SCRIPT, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('installationSource'), 'exclude': lambda f: f is None }})
    internal_registry_parameters: Optional[InternalRegistryParameters] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('internalRegistryParameters'), 'exclude': lambda f: f is None }})
    r"""internal registry information"""
    is_hold_application_until_proxy_starts: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isHoldApplicationUntilProxyStarts'), 'exclude': lambda f: f is None }})
    r"""indicates whether the controller should hold the application until the proxy starts"""
    is_istio_ingress_enabled: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isIstioIngressEnabled'), 'exclude': lambda f: f is None }})
    r"""indicates whether Istio ingress is enabled"""
    is_multi_cluster: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isMultiCluster'), 'exclude': lambda f: f is None }})
    r"""indicates whether this cluster should support multi-cluster communication"""
    is_persistent: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isPersistent'), 'exclude': lambda f: f is None }})
    r"""indicates whether the agent should run in persistent mode"""
    istio_ingress_annotations: Optional[List[KubernetesAnnotation]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('istioIngressAnnotations'), 'exclude': lambda f: f is None }})
    r"""annotations for load balancers"""
    istio_installation_parameters: Optional[IstioInstallationParameters] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('istioInstallationParameters'), 'exclude': lambda f: f is None }})
    r"""istio related information"""
    k8s_events_enabled: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('k8sEventsEnabled'), 'exclude': lambda f: f is None }})
    r"""indicates whether kubernetes events sending is enabled"""
    kubernetes_security: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('kubernetesSecurity'), 'exclude': lambda f: f is None }})
    r"""indicates whether kubernetes security is enabled"""
    minimal_number_of_controller_replicas: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('minimalNumberOfControllerReplicas'), 'exclude': lambda f: f is None }})
    orchestration_type: Optional[OrchestrationType] = dataclasses.field(default=OrchestrationType.GKE, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('orchestrationType'), 'exclude': lambda f: f is None }})
    preserve_original_source_ip: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('preserveOriginalSourceIp'), 'exclude': lambda f: f is None }})
    r"""indicates whether the agent should preserve the original source ip"""
    proxy_configuration: Optional[ProxyConfiguration] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('proxyConfiguration'), 'exclude': lambda f: f is None }})
    restrict_registires: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('restrictRegistires'), 'exclude': lambda f: f is None }})
    r"""indicates whether the agent validate the images origin"""
    scan_configuration: Optional[ScanConfiguration] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('scanConfiguration'), 'exclude': lambda f: f is None }})
    r"""scan configuration information"""
    service_discovery_isolation_enabled: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('serviceDiscoveryIsolationEnabled'), 'exclude': lambda f: f is None }})
    r"""indicates whether the service discovery isolation is enabled"""
    sidecars_resources: Optional[SidecarsResource] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sidecarsResources'), 'exclude': lambda f: f is None }})
    ssh_monitor_disabled: Optional[bool] = dataclasses.field(default=True, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sshMonitorDisabled'), 'exclude': lambda f: f is None }})
    r"""indicates whether SSH monitoring is disabled"""
    support_external_trace_source: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('supportExternalTraceSource'), 'exclude': lambda f: f is None }})
    r"""indicates whether external trace sources are supported"""
    tls_inspection_enabled: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tlsInspectionEnabled'), 'exclude': lambda f: f is None }})
    r"""indicates whether TLS inspection is enabled"""
    token_injection_enabled: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tokenInjectionEnabled'), 'exclude': lambda f: f is None }})
    r"""indicates whether token injection is enabled"""
    use_external_ca: Optional[bool] = dataclasses.field(default=False, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('useExternalCA'), 'exclude': lambda f: f is None }})
    r"""indicates whether kubernetes should use external CA"""
    

